{"name":"Trabalho 3 LES","tagline":"MetaData Mapping, Query Object, Repository","body":"\r\n# **\"Patterns of Enterprise Application Architecture\" Martin Fowler**\r\n# **Chapter 13: ObjectRelational Metadata Mapping Patterns**\r\n\r\n***\r\n## **MetaData Mapping (Mapeamento de Metadados)**\r\n\r\n### **Como Funciona**\r\nCódigos que lidam com mapeamento objeto-relacional descrevem como os campos no banco de dados se relacionam com os objetos em memória. Esse código tende a ser repetitivo e tedioso para um programador. Com o mapeamento em metadados permite-se que os desenvolvedores defina os mapeamentos em forma tabular.\r\nMaior decisão a ser tomada, é como as informações se expressão em em execução:\r\n\r\nGeração de código: Escreve-se um programa onde as entradas são os metadados e a saída é o código fonte das classes. Essas classes são inteiramente geradas durante o processo, importante que as classes estejam integradas com seu build e essas classes nunca devem ser editadas. É uma abordagem menos dinâmica, já que a alteração requer recompilação.\r\n\r\nPrograma reflexivo: Quando um método é solicitado um determinado objeto que ao executar esse método passa o parâmetro apropriado. Tratando os dados passados, o programa reflexivo pode ler os nomes de campos e métodos e utilizar isso para gerar o mapeamento. O autor desaconselha a reflexão porque ele é lenta, mas principalmente pois gera códigos difícil de debugar . Nessa abordagem alterando ao arquivo de mapeamento as classes usarão os novos metadados, podendo ser feito até em tempo de execução.\r\n\r\nA velocidade depende do ambiente onde estará sendo usada.\r\nAmbas as abordagens podem ser complicadas para depurar vai depender do quão habituados estão os desenvolvedores com cada tipo de código.\r\nAlteração nos mapeamentos deveriam ser bastante raras já que implicam em alterações no banco de dados ou no código.\r\n\r\nNa maioria dos casos se mantêm os metadados em uma arquivo XML separado, pois esse formato fornece uma estrutura hierárquica. Em alguns casos mais simples pode-se criar a representação diretamente no código fonte.\r\n\r\nUm dos desafios dos metados é que existem casos onde terá que ser adicionado uma grande complexidade de metadados, uma alternativa útil é sobrescrever o código genérico\r\n\r\n### **Quando usar**\r\n\r\nEsse padrão reduz muito a quantidade de trabalho para tratar o mapeamento em um banco de dados, mas o trabalho de configuração é requerido para preparar o framework.\r\nO mapeamento em metadados pode interferir na refatoração,  mas por outro lado pode tornar a refatoração no banco de dados mais fácil, já que os metados representam uma declaração na interface.\r\n\r\n### **Exemplo**\r\n\r\n\r\n\r\n***\r\n\r\n## **Query Object (Objeto de Pesquisa)**\r\n\r\n\r\n\r\n### **Como funciona**\r\nUm objeto de pesquisa é um interpretador, pode-se criar a consulta fazendo referência a classes e a campos em vez de tabelas e colunas.\r\nÉ uma aplicação do padrçao Interpretador desinado a representar uma consulta SQL. Suas principais tarefas são permitir ao cliente formular consultas e transformar estruturas em objetos na string SQL.\r\nUma caracteristica comum do objeto de pesquisa é que ele pode representar consultas na linguagem dos objetos na memória em vez da linguagem do esquema do banco de dados(usar nomes de objetos e campos em vez de usar nomes de tabelas e colunas). Para efetuar essa mudança o objeto de pesquisa precisa saber como está a estrutura do banco de dados, essa é uma habilidade que precisa de do Mapeamento de Metadados.\r\nUm uso do Objeto de pesquisa é para eliminar pesquisas redundantes sobre um banco. Se a consulta já foi vista basta consultar os objetos do Mapa de identidade, evitando assim uma ida ao banco de dados, outra abordagem é para detectar consultas que são casos particulares de outras.\r\nUma variação consistem em permitir que uma consulta seja especificada por um exemplo de objeto de domínio. Assim poderia ter um objeto com apenas um campo preenchido, o restante seria nulo.\r\n\r\n### **Quando usar**\r\n\r\nÉ um padrão bastante sofisticado para se construir, portanto a maioria dos projetos não  usa.\r\nVantagens desse padrão: Manter esquemas de banco de dados encapsulados, suportar múltiplos banco de dados, otimizar consultas e suportar múltiplos esquemas.\r\n\r\n### **Exemplo**\r\n\r\n\r\n***\r\n\r\n## **Repository (Repositório)**\r\n\r\n### **Como funciona**\r\nUm repositório realiza a medição entre as camadas mapeadoras de dados e as camadas de domínio, agindo como uma coleção de objeto.Esses objetos criam especifiações de consultas e submetem ao repositório.\r\nEle é uma junção de de outros padrões, eles se parece com um pequeno banco de dados orientado a objetos.\r\n\r\n### **Quando usar**\r\n\r\n### **Exemplo**\r\n\r\n***\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}