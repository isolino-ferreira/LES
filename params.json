{"name":"Trabalho 3 LES","tagline":"MetaData Mapping, Query Object, Repository","body":"\r\n# **\"Patterns of Enterprise Application Architecture\" Martin Fowler**\r\n# **Chapter 13: ObjectRelational Metadata Mapping Patterns**\r\n\r\n***\r\n## **MetaData Mapping (Mapeamento de Metadados)**\r\n\r\n### **Como Funciona**\r\nCódigos que lidam com mapeamento objeto-relacional descrevem como os campos no banco de dados se relacionam com os objetos em memória. Esse código tende a ser repetitivo e tedioso para um programador. Com o mapeamento em metadados permite-se que os desenvolvedores defina os mapeamentos em forma tabular.\r\nMaior decisão a ser tomada, é como as informações se expressão em em execução:\r\n\r\nGeração de código: Escreve-se um programa onde as entradas são os metadados e a saída é o código fonte das classes. Essas classes são inteiramente geradas durante o processo, importante que as classes estejam integradas com seu build e essas classes nunca devem ser editadas. É uma abordagem menos dinâmica, já que a alteração requer recompilação.\r\n\r\nPrograma reflexivo: Quando um método é solicitado um determinado objeto que ao executar esse método passa o parâmetro apropriado. Tratando os dados passados, o programa reflexivo pode ler os nomes de campos e métodos e utilizar isso para gerar o mapeamento. O autor desaconselha a reflexão porque ele é lenta, mas principalmente pois gera códigos difícil de debugar . Nessa abordagem alterando ao arquivo de mapeamento as classes usarão os novos metadados, podendo ser feito até em tempo de execução.\r\n\r\nA velocidade depende do ambiente onde estará sendo usada.\r\nAmbas as abordagens podem ser complicadas para depurar vai depender do quão habituados estão os desenvolvedores com cada tipo de código.\r\nAlteração nos mapeamentos deveriam ser bastante raras já que implicam em alterações no banco de dados ou no código.\r\n\r\nNa maioria dos casos se mantêm os metadados em uma arquivo XML separado, pois esse formato fornece uma estrutura hierárquica. Em alguns casos mais simples pode-se criar a representação diretamente no código fonte.\r\n\r\nUm dos desafios dos metados é que existem casos onde terá que ser adicionado uma grande complexidade de metadados, uma alternativa útil é sobrescrever o código genérico\r\n\r\n### **Quando usar**\r\n\r\nEsse padrão reduz muito a quantidade de trabalho para tratar o mapeamento em um banco de dados, mas o trabalho de configuração é requerido para preparar o framework.\r\nO mapeamento em metadados pode interferir na refatoração,  mas por outro lado pode tornar a refatoração no banco de dados mais fácil, já que os metados representam uma declaração na interface.\r\n\r\n### **Exemplo**\r\n\r\n\r\n\r\n***\r\n\r\n## **Query Object (Objeto de Pesquisa)**\r\n\r\n\r\n\r\n### **Como funciona**\r\nUm objeto de pesquisa é um interpretador, pode-se criar a consulta fazendo referência a classes e a campos em vez de tabelas e colunas.\r\nÉ uma aplicação do padrão Interpretador destinado a representar uma consulta SQL. Suas principais tarefas são permitir ao cliente formular consultas e transformar estruturas em objetos na string SQL.\r\nUma caracteristica comum do objeto de pesquisa é que ele pode representar consultas na linguagem dos objetos na memória em vez da linguagem do esquema do banco de dados(usar nomes de objetos e campos em vez de usar nomes de tabelas e colunas). Para efetuar essa mudança o objeto de pesquisa precisa saber como está a estrutura do banco de dados, essa é uma habilidade que precisa de do Mapeamento de Metadados.\r\nUm uso do Objeto de pesquisa é para eliminar pesquisas redundantes sobre um banco. Se a consulta já foi vista basta consultar os objetos do Mapa de identidade, evitando assim uma ida ao banco de dados, outra abordagem é para detectar consultas que são casos particulares de outras.\r\nUma variação consistem em permitir que uma consulta seja especificada por um exemplo de objeto de domínio. Assim poderia ter um objeto com apenas um campo preenchido, o restante seria nulo.\r\n\r\n### **Quando usar**\r\n\r\nÉ um padrão bastante sofisticado para se construir, portanto a maioria dos projetos não  usa.\r\nVantagens desse padrão: Manter esquemas de banco de dados encapsulados, suportar múltiplos banco de dados, otimizar consultas e suportar múltiplos esquemas.\r\n\r\n### **Exemplo**\r\nO exemplo são usando uma simulação de um banco de dados em forma de lista\r\nEstá é a classe onde guardará os meus critérios de consulta\r\n`public class Criterios {`\r\n    `private String nome;`\r\n    `private String sobrenome;`\r\n\r\n    `public String getNome() {`\r\n        `return nome;`\r\n    `}`\r\n\r\n    `public void setNome(String nome) {`\r\n        `this.nome = nome;`\r\n    `}`\r\n\r\n    `public String getSobrenome() {`\r\n        `return sobrenome;`\r\n    `}`\r\n\r\n    `public void setSobrenome(String sobrenome) {`\r\n        `this.sobrenome = sobrenome;`\r\n    `}`\r\n`}`\r\n\r\nAqui está a classe responsavel pelas consultas\r\n\r\n`public class ObjetoPesquisa {`\r\n    `ArrayList<Criterios> elementos = new ArrayList<>();`\r\n    \r\n    `public void salvarDados(Criterios criterios){`\r\n        `elementos.add(criterios);`\r\n        `System.out.println(\"**************DADOS SALVOS************\");`\r\n        \r\n        \r\n    `}`\r\n    \r\n    `public void apagarDados(Criterios criterios){`\r\n        `int index = 0;`\r\n        `for (int i = 0; i < elementos.size(); i++) {`\r\n            `if(elementos.get(i).getNome().equals(criterios.getNome())){`\r\n                `index=i;`\r\n            `}`\r\n        `}`\r\n        `elementos.remove(index);`\r\n        \r\n        \r\n    `}`\r\n        \r\n    `void selecionarDados(Criterios criterios) {`\r\n        `for (Criterios elemento : elementos) {`\r\n            `if(elemento.getNome().equals(criterios.getNome())){`\r\n                `System.out.println(\"**************DADO ENCONTRADO************\");`\r\n                `System.out.println(\"Nome: \"+ elemento.getNome());`\r\n                `System.out.println(\"Sobrenome: \"+ elemento.getSobrenome());`\r\n                `System.out.println(\"**************DADO ENCONTRADO************\");`\r\n            `}`\r\n        `}`\r\n    `}`\r\n    \r\n    `void atualizarrDados(Criterios criterios) {`\r\n        `for (Criterios elemento : elementos) {`\r\n            `if(elemento.getNome().equals(criterios.getNome())){`\r\n                `System.out.println(\"**************DADO ATUALIZADO************\");`\r\n                `elemento.setNome(\"NovoNome\");`\r\n                `elemento.setSobrenome(\"NovoSobrenome\");`\r\n            `}`\r\n        `}`\r\n    `}`\r\n    \r\n    `void imprime(){`\r\n        `System.out.println(\"**************LISTA************\");`\r\n        `for (Criterios imprime : elementos){`\r\n            `System.out.println(\"Nome: \"+ imprime.getNome());`\r\n            `System.out.println(\"Sobrenome: \"+ imprime.getSobrenome());`\r\n        `}`\r\n        `System.out.println(\"**************LISTA************\");`\r\n\r\n    `}`\r\n`}`\r\n\r\nAbaixo temos a main\r\n\r\n`public static void main(String[] args) {`\r\n        \r\n        `ObjetoPesquisa objetoPesquisa = new ObjetoPesquisa();`\r\n        `//Insert`\r\n        `Criterios meusCriterios = new Criterios();`\r\n        `meusCriterios.setNome(\"Marcelo\");`\r\n        `meusCriterios.setSobrenome(\"Silva\");`\r\n        `objetoPesquisa.salvarDados(meusCriterios);`\r\n        `meusCriterios = new Criterios();`\r\n        `meusCriterios.setNome(\"Pedro\");`\r\n        `meusCriterios.setSobrenome(\"Silva\");`\r\n        `objetoPesquisa.salvarDados(meusCriterios);`\r\n        `meusCriterios = new Criterios();`\r\n        `meusCriterios.setNome(\"José\");`\r\n        `meusCriterios.setSobrenome(\"Carlos\");`\r\n        `objetoPesquisa.salvarDados(meusCriterios);`\r\n        `objetoPesquisa.imprime();`\r\n        `//Select`\r\n        `meusCriterios = new Criterios();`\r\n        `meusCriterios.setNome(\"José\");`\r\n        `objetoPesquisa.selecionarDados(meusCriterios);`\r\n        `objetoPesquisa.imprime();`\r\n        `//Delete`\r\n        `meusCriterios = new Criterios();`\r\n        `meusCriterios.setNome(\"Pedro\");`\r\n        `meusCriterios.setSobrenome(\"Silva\");`\r\n        `objetoPesquisa.apagarDados(meusCriterios);`\r\n        `objetoPesquisa.imprime();`\r\n        `//Update`\r\n        `meusCriterios = new Criterios();`\r\n        `meusCriterios.setNome(\"José\");`\r\n        `meusCriterios.setSobrenome(\"Carlos\");`\r\n        `objetoPesquisa.atualizarrDados(meusCriterios);`\r\n        `objetoPesquisa.imprime();`\r\n    `}`\r\n\r\n***\r\n\r\n## **Repository (Repositório)**\r\n\r\n### **Como funciona**\r\nEle é uma junção de de outros padrões, eles se parece com um pequeno banco de dados orientado a objetos.\r\nExiste um  objeto repositório que “simula” um banco de dados. Assim aplicação cliente não acesso a fonte de dados real, que pode ser um simples banco de dados relacional ou um fluxo XML, ou ainda a combinação de muitos bancos,no entanto ela acessa ao repositório através de métodos que recebem como parametros critérios usados para procurar objetos específicos que pertenção ao repositório. Podemos dizer que o repositório é uma grande coleção de dados e permite ao cliente procurar por objetos e não se preocupar com SQL.\r\nPara encontrar um objeto o cliente deve especificar os critérios de busca, tendo feito isso acontece a busca no repositório usando as informações que foram passadas, para então retornar uma lista de objetos ou um objeto do domínio que possa representar as informações que foram solicitadas.\r\nO código de um repositório se parece com uma coleção de objetos do domínio em memória. O repositório combina o Mapeamento em metadados com objeto de pesquisa, para gerar automaticamente o codigo SQL a partir dos critérios que foram passados. Sua utilização pode melhorar a legibilidade e a clareza em um código que faz uso extensivo de consultas.\r\n\r\n### **Quando usar**\r\nEm sistemas grandes com muitos tipos de objetos de domínio e muitas pesquisas possíveis esse padrão reduz a quantidade o código necessário. Promove o padrão Especificação, que encapsula a consulta a ser realizada de uma forma puramente orientada a objeto.\r\n\r\n### **Exemplo**\r\nO exemplo são usando uma simulação de um banco de dados em forma de lista\r\nEstá é a classe onde guardará os meus critérios de consulta\r\n`public class Criterios {`\r\n    `private String nome;`\r\n    `private String sobrenome;`\r\n\r\n    `public String getNome() {`\r\n        `return nome;`\r\n    `}`\r\n\r\n    `public void setNome(String nome) {`\r\n        `this.nome = nome;`\r\n    `}`\r\n\r\n    `public String getSobrenome() {`\r\n        `return sobrenome;`\r\n    `}`\r\n\r\n    `public void setSobrenome(String sobrenome) {`\r\n        `this.sobrenome = sobrenome;`\r\n    `}`\r\n`}`\r\n\r\nAqui é o meu repositorio\r\n\r\n\r\n`public class Repositorio {`\r\n    `ArrayList<Criterios> elementos = new ArrayList<>();`\r\n\r\n    `public Repositorio() {`\r\n        `//Adição de dados para o repositorio`\r\n        `novo = new Criterios();`\r\n        `novo.setNome(\"Nome\");`\r\n        `novo.setSobrenome(\"Sobrenome\");`\r\n        `this.elementos.add(novo);`\r\n      `}`\r\n    \r\n    \r\n    `public void buscaNome(Criterios criterios){`\r\n        `ArrayList<Criterios> retorno = new ArrayList<>();`\r\n        `for (Criterios lista : elementos) {`\r\n            `if(lista.getNome().equals(criterios.getNome())){`\r\n                `retorno.add(lista);`\r\n            `}`\r\n        `}`\r\n        `System.out.println(\"**************IMPRIME NOME************\");`\r\n        `System.out.println(\"**************BUSCANDO POR Nome************\");`\r\n       `for (Criterios imprime : retorno) {`\r\n           \r\n            `System.out.println(\"Nome: \"+ imprime.getNome());`\r\n            `System.out.println(\"Sobrenome: \"+ imprime.getSobrenome());`\r\n        `}`\r\n    `}`\r\n    \r\n    `public void buscaSobrenome(Criterios criterios){`\r\n        `ArrayList<Criterios> retorno = new ArrayList<>();`\r\n        `for (Criterios lista : elementos) {`\r\n            `if(lista.getSobrenome().equals(criterios.getSobrenome())){`\r\n                `retorno.add(lista);`\r\n            `}`\r\n        `}`\r\n        `System.out.println(\"**************IMPRIME SOBRENOME************\");`\r\n        `System.out.println(\"**************BUSCANDO POR Sobrenome************\");`\r\n        `for (Criterios imprime : retorno){`\r\n            `System.out.println(\"Nome: \"+ imprime.getNome());`\r\n            `System.out.println(\"Sobrenome: \"+ imprime.getSobrenome());`\r\n        `}`\r\n        \r\n    `}`\r\n`}`\r\n\r\nAqui no main é onde acontece a chamada das consultas\r\n\r\n\r\n`public static void main(String[] args) {`\r\n        \r\n        `Repositorio meuRepositorio = new Repositorio();`\r\n        `Criterios meusCriterios1 = new Criterios();`\r\n        `meusCriterios1.setNome(\"Nome\");`\r\n        `meuRepositorio.buscaNome(meusCriterios1);`\r\n        \r\n        `Criterios meusCriterios2 = new Criterios();`\r\n        `meusCriterios2.setSobrenome(\"Sobrenome\");`\r\n        `meuRepositorio.buscaSobrenome(meusCriterios2);`\r\n    `}`\r\n***","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}